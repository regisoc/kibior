% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/api.R, R/kibior.R
\docType{class}
\name{kibior}
\alias{kibior}
\alias{Kibior}
\title{KibioR, an Kibio and Elasticsearch data manipulation package.}
\format{
\code{\link{R6Class}} object.
}
\description{
KibioR is a lightweight package for data manipulation 
 with Elasticsearch. Its main features allow easy data import, export,
 download, upload, searching and sharing to any Elasticsearch-based open 
 architecture, scaling to billions of data and TB capability.

Kibior is a Kibio/Elasticsearch client written with R6 class. 
Instances of Kibior are object that allow to use Elasticsearch power and execute lots of predefined 
requests such as searching in massive amounts of data, joins between in-memory data and Elasticsearch 
indices, push and pull data to and from multiples Elasticsearch servers, and more. This little 
utilitary was built in the context of massive data invading biology and bioinformatics, but is completely
versatile and can be applied to other fields. By adding it to R-scripts, it can perform several 
useful tasks such as: saving intermediary results, sharing them with a collaborator, automating 
import and upload of lots of files directly, and much more.
}
\details{
A client to send, retrieve, search, join data in Elasticsearch.
}
\section{Constructor Arguments}{

 \tabular{llll}{
 \strong{Argument} \tab \strong{Type} \tab \strong{Details} \tab \strong{Default} \cr
 \code{host} \tab character \tab address or name of Elasticsearch server \tab "localhost" \cr
 \code{port} \tab numeric \tab port of Elasticsearch server \tab 9200 \cr
 \code{user} \tab character \tab if required by the server, the username for authentication \tab NULL \cr
 \code{pwd} \tab character \tab if required by the server, the password for authentication \tab NULL \cr
 \code{verbose} \tab logical \tab verbose mode \tab FALSE \cr
 }

 created
}

\examples{

## ------------------------------------------------
## Method `Kibior$new`
## ------------------------------------------------

\dontrun{
# default initiatlization, connect to "localhost:9200"
kc <- Kibior$new()
# connect to "192.168.2.145:9200"
kc <- Kibior$new("192.168.2.145")
# connect to "es:15005", verbose mode activated
kc <- Kibior$new(host = "elasticsearch", port = 15005, verbose = TRUE)
# connect to "192.168.2.145:9450" with credentials "foo:bar"
kc <- Kibior$new(host = "192.168.2.145", port = 9450, user = "foo", pwd = "bar")
# connect to "elasticsearch:9200"
kc <- Kibior$new("elasticsearch")
}

# get kibior var from ".Renviron" file
dd <- system.file("doc_env", "kibior_build.R", package = "kibior")
source(dd, local = TRUE)
kc <- .kibior_get_instance_from_env()
kc$quiet_progress <- TRUE

# preparing all examples (do not mind this for this method)
to_delete <- c(
    "aaa", 
    "bbb", 
    "ccc", 
    "ddd", 
    "sw", 
    "sw_naboo", 
    "sw_tatooine", 
    "sw_alderaan", 
    "sw_from_file", 
    "storms"
)
to_delete[kc$has(to_delete)] \%>\%
    names() \%>\%
    kc$delete()


## ------------------------------------------------
## Method `Kibior$print`
## ------------------------------------------------

print(kc)


## ------------------------------------------------
## Method `Kibior$eq`
## ------------------------------------------------

kc$eq(kc)



## ------------------------------------------------
## Method `Kibior$ne`
## ------------------------------------------------

kc$ne(kc)


## ------------------------------------------------
## Method `Kibior$create`
## ------------------------------------------------

kc$create("aaa")
kc$create(c("bbb", "ccc"))


## ------------------------------------------------
## Method `Kibior$list`
## ------------------------------------------------

kc$list()
kc$list(get_specials = TRUE)


## ------------------------------------------------
## Method `Kibior$has`
## ------------------------------------------------

kc$has("aaa")
c("bbb", "ccc") \%>\% kc$has()


## ------------------------------------------------
## Method `Kibior$delete`
## ------------------------------------------------

kc$delete("aaa")
kc$delete(c("bbb", "ccc"))


## ------------------------------------------------
## Method `Kibior$stats`
## ------------------------------------------------

kc$stats()


## ------------------------------------------------
## Method `Kibior$ping`
## ------------------------------------------------

kc$ping()


## ------------------------------------------------
## Method `Kibior$metadata`
## ------------------------------------------------

# push test data, without magrittr
kc$push(dplyr::starwars, "sw")
kc$push(dplyr::filter(dplyr::starwars, homeworld == "Naboo"), "sw_naboo")
kc$push(dplyr::filter(dplyr::starwars, homeworld == "Tatooine"), "sw_tatooine")
kc$push(dplyr::filter(dplyr::starwars, homeworld == "Alderaan"), "sw_alderaan")
# metadata
kc$metadata()
kc$metadata("sw")
kc$metadata(c("sw", "sw_naboo"))


## ------------------------------------------------
## Method `Kibior$mappings`
## ------------------------------------------------

kc$mappings()
kc$mappings("sw")
kc$mappings(c("sw", "sw_naboo"))


## ------------------------------------------------
## Method `Kibior$settings`
## ------------------------------------------------

kc$settings()
kc$settings("sw")
kc$settings(c("sw", "sw_tatooine"))


## ------------------------------------------------
## Method `Kibior$aliases`
## ------------------------------------------------

kc$aliases()
kc$aliases("sw")
kc$aliases(c("sw", "sw_alderaan"))


## ------------------------------------------------
## Method `Kibior$count`
## ------------------------------------------------

# Number of observations (nb of records) in "sw"
kc$count("sw")
# Number of observations in indices "sw_naboo" and "sw_tatooine"
kc$count(c("sw_naboo", "sw_tatooine"))
# Number of variables (nb of columns) in index "sw_naboo"
kc$count("sw_naboo", type = "variables")


## ------------------------------------------------
## Method `Kibior$dim`
## ------------------------------------------------

# Couple [<nb obs> <nb var>] in "sw"
kc$dim("sw")
# Couple [<nb obs> <nb var>] in indices "sw_naboo" and "sw_alderaan"
kc$dim(c("sw_naboo", "sw_alderaan"))


## ------------------------------------------------
## Method `Kibior$columns`
## ------------------------------------------------

kc$columns("sw")          # direct search
kc$columns("sw_*")        # pattern search


## ------------------------------------------------
## Method `Kibior$keys`
## ------------------------------------------------

kc$keys("sw", "name")
kc$keys("sw", "eye_color")


## ------------------------------------------------
## Method `Kibior$bam_to_tibble`
## ------------------------------------------------

dd_bai <- system.file("extdata", "test.bam.bai", package = "kibior")
bam_param <- Rsamtools::ScanBamParam(what = c("pos", "qwidth"))
bam_data <- Rsamtools::scanBam(dd_bai, param = bam_param)
kc$bam_to_tibble(bam_data)


## ------------------------------------------------
## Method `Kibior$soft_cast`
## ------------------------------------------------

datasets::iris \%>\% kc$soft_cast()


## ------------------------------------------------
## Method `Kibior$get_resource`
## ------------------------------------------------

system.file("R", "kibior.R", package = "kibior") \%>\% 
 kc$get_resource()
"https://ftp.ncbi.nlm.nih.gov/entrez/README" \%>\% kc$get_resource()


## ------------------------------------------------
## Method `Kibior$export`
## ------------------------------------------------

f <- tempfile(fileext=".csv")
# export and overwrite last file with the same data from Elasticsearch
kc$export(data = "sw", filepath = f)
# export from in-memory data to a file
kc$export(data = dplyr::starwars, filepath = f, force = TRUE)


## ------------------------------------------------
## Method `Kibior$import_tabular`
## ------------------------------------------------

f <- tempfile(fileext = ".csv")
rio::export(ggplot2::diamonds, f)
# import to in-memory variable
kc$import_tabular(filepath = f)
# import raw data
kc$import_tabular(filepath = f, to_tibble = FALSE)


## ------------------------------------------------
## Method `Kibior$import_features`
## ------------------------------------------------

# get sample files
f_gff <- system.file("extdata", "chr_y.gff3.gz", package = "kibior")
f_bed <- system.file("extdata", "cpg.bed", package = "kibior")
# import to in-memory variable
kc$import_features(filepath = f_bed)
kc$import_features(filepath = f_gff)
# import raw data
kc$import_features(filepath = f_bed, to_tibble = FALSE)
kc$import_features(filepath = f_gff, to_tibble = FALSE)


## ------------------------------------------------
## Method `Kibior$import_alignments`
## ------------------------------------------------

# get sample file
f_bai <- system.file("extdata", "test.bam.bai", package = "kibior")
# import to in-memory variable
kc$import_alignments(filepath = f_bai)
# import raw data
kc$import_alignments(filepath = f_bai, to_tibble = FALSE)


## ------------------------------------------------
## Method `Kibior$import_json`
## ------------------------------------------------

# get sample file
f_json <- system.file("extdata", "storms100.json", package = "kibior")
# import to in-memory variable
kc$import_json(f_json)
# import raw data
kc$import_json(f_json, to_tibble = FALSE)


## ------------------------------------------------
## Method `Kibior$import_sequences`
## ------------------------------------------------

# get sample file
f_dna <- system.file("extdata", "dna_human_y.fa.gz", package = "kibior")
f_rna <- system.file("extdata", "ncrna_mus_musculus.fa.gz", package = "kibior")
f_aa <- system.file("extdata", "pep_mus_spretus.fa.gz", package = "kibior")
# import to in-memory variable
kc$import_sequences(filepath = f_dna, fasta_type = "dna")
# import raw data
kc$import_sequences(filepath = f_rna, to_tibble = FALSE, fasta_type = "rna")
# import auto
kc$import_sequences(filepath = f_aa)


## ------------------------------------------------
## Method `Kibior$guess_import`
## ------------------------------------------------

# get sample file
f_dna <- system.file("extdata", "dna_human_y.fa.gz", package = "kibior")
f_rna <- system.file("extdata", "ncrna_mus_musculus.fa.gz", package = "kibior")
f_aa <- system.file("extdata", "pep_mus_spretus.fa.gz", package = "kibior")
f_bai <- system.file("extdata", "test.bam.bai", package = "kibior")
f_gff <- system.file("extdata", "chr_y.gff3.gz", package = "kibior")
f_bed <- system.file("extdata", "cpg.bed", package = "kibior")
# import 
kc$guess_import(f_dna)
kc$guess_import(f_rna)
kc$guess_import(f_aa)
kc$guess_import(f_bai)
kc$guess_import(f_gff)
kc$guess_import(f_bed)


## ------------------------------------------------
## Method `Kibior$import`
## ------------------------------------------------

# get sample file
f_aa <- system.file("extdata", "pep_mus_spretus.fa.gz", package = "kibior")
f_gff <- system.file("extdata", "chr_y.gff3.gz", package = "kibior")
f_bai <- system.file("extdata", "test.bam.bai", package = "kibior")
# import 
kc$import(filepath = f_aa)
# import to Elasticsearch index ("sw_from_file") if not exists
kc$import(filepath = f_bai, push_index = "sw_from_file")
# import to index by recreating it, then pull indexed data
kc$import(filepath = f_gff, push_index = "sw_from_file",
 push_mode = "recreate")


## ------------------------------------------------
## Method `Kibior$push`
## ------------------------------------------------

# erase the last push data by recreating the index and re-pushing data
kc$push(dplyr::starwars, index_name = "sw", mode = "recreate")
# characters names are unique, can be used as ID
kc$push(dplyr::starwars, index_name = "sw", mode = "recreate", id_col = "name")
# a bit more complicated: update some data of the dataset "starwars"
# 38 records on 87 filtered
some_new_data <- dplyr::filter(dplyr::starwars, height > 180)
# make them all "gender <- female"
some_new_data["gender"] <- "female"
# update that apply, based on cahracter names to match the right record
kc$push(some_new_data, "sw", mode = "update", id_col = "name")
# view result by querying
kc$pull("sw", query = "height:>180", columns = c("name", "gender"))


## ------------------------------------------------
## Method `Kibior$pull`
## ------------------------------------------------

# push some data sample
kc$push(dplyr::storms, "storms")
# get the whole "sw" index
kc$pull("sw")
# get the whole "sw" index with all metadata
kc$pull("sw", keep_metadata = TRUE)
# get only "name" and "status" columns of indices starting with "s"
# columns not found will be ignored
kc$pull("s*", columns = c("name", "status"))
# limit the size of the result to 10
kc$pull("storms", max_size = 10, bulk_size = 10)
# use Elasticsearch query syntax to select and filter on all indices, for all data
# Here, we want to search for all records taht match the conditions:
# field "height" is strictly more than 180 AND field homeworld is "Tatooine" OR "Naboo"
r <- kc$pull("sw", query = "height:>180 && homeworld:(Tatooine || Naboo)")
# it can be used in conjunction with `columns` to select only columns that matter
r <- kc$pull("sw", query = "height:>180 && homeworld:(Tatooine || Naboo)", columns = 
 c("name", "hair_color", "homeworld"))


## ------------------------------------------------
## Method `Kibior$move`
## ------------------------------------------------

kc$push(dplyr::starwars, "sw", mode = "recreate")
# move data from an index to another (change name, same instance)
r <- kc$move(from_index = "sw", to_index = "sw_new")
kc$pull("sw_new")
kc$list() 


## ------------------------------------------------
## Method `Kibior$copy`
## ------------------------------------------------

# copy data from one index to another (same instance)
r <- kc$copy(from_index = "sw_new", to_index = "sw")
kc$pull(c("sw", "sw_new"))
kc$list() 


## ------------------------------------------------
## Method `Kibior$match`
## ------------------------------------------------

# search "sw" index name
kc$match("sw")
# search all starting with an "s"
kc$match("s*")
# get all index name, identical to `$list()`
kc$match("*")
# search multiple names 
kc$match(c("sw", "sw_new", "nope"))
# search multiple names with pattern
kc$match(c("s*", "nope"))


## ------------------------------------------------
## Method `Kibior$search`
## ------------------------------------------------

# search "sw" index, head mode on
kc$search("sw")
# search "sw" index with all metadata, head mode on
kc$search("sw", keep_metadata = TRUE)
# get only "name" field of the head of indices starting with "s"
# if an index does not have the "name" field, it will be empty
kc$search("s*", columns = "name")
# limit the size of the result to 50 to the whole index
kc$search("storms", max_size = 50, bulk_size = 50, head = FALSE)
# use Elasticsearch query syntax to select and filter on all indices, for all data
# Here, we want to search for all records taht match the conditions:
# field "height" is strictly more than 180 AND field homeworld is "Tatooine" OR "Naboo"
kc$search("*", query = "height:>180 && homeworld:(Tatooine || Naboo)")
# it can be used in conjunction with `columns` to select only columns that matter
kc$search("*", query = "height:>180 && homeworld:(Tatooine || Naboo)", columns = 
 c("name", "hair_color", "homeworld"))


## ------------------------------------------------
## Method `Kibior$inner_join`
## ------------------------------------------------

# some data for joins examples
kc$push(ggplot2::diamonds, "diamonds")
# prepare join datasets, only big the biggest diamonds are selected (9)
sup_carat <- dplyr::filter(ggplot2::diamonds, carat > 3.5)
r <- kc$push(sup_carat, "diamonds_superior")
# execute a inner_join with one index and one in-memory dataset
kc$inner_join(ggplot2::diamonds, "diamonds_superior")
# execute a inner_join with one index queried, and one in-memory dataset
kc$inner_join(ggplot2::diamonds, "diamonds", right_query 
 = "carat:>3.5")


## ------------------------------------------------
## Method `Kibior$full_join`
## ------------------------------------------------

# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a full_join with one index and one in-memory dataset
kc$full_join(fair_cut, "diamonds_superior")
# execute a full_join with one index queried, and one in-memory dataset
kc$full_join(sup_carat, "diamonds", right_query = "cut:fair")


## ------------------------------------------------
## Method `Kibior$left_join`
## ------------------------------------------------

# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a left_join with one index and one in-memory dataset
kc$left_join(fair_cut, "diamonds_superior")
# execute a left_join with one index queried, and one in-memory dataset
kc$left_join(sup_carat, "diamonds", right_query 
 = "cut:fair")


## ------------------------------------------------
## Method `Kibior$right_join`
## ------------------------------------------------

# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a right_join with one index and one in-memory dataset
kc$right_join(fair_cut, "diamonds_superior")
# execute a right_join with one index queried, and one in-memory dataset
kc$right_join(sup_carat, "diamonds", right_query 
 = "cut:fair")


## ------------------------------------------------
## Method `Kibior$semi_join`
## ------------------------------------------------

# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a semi_join with one index and one in-memory dataset
kc$semi_join(fair_cut, "diamonds_superior")
# execute a semi_join with one index queried, and one in-memory dataset
kc$semi_join(sup_carat, "diamonds", right_query 
 = "cut:fair")


## ------------------------------------------------
## Method `Kibior$anti_join`
## ------------------------------------------------

# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a anti_join with one index and one in-memory dataset
kc$anti_join(fair_cut, "diamonds_superior")
# execute a anti_join with one index queried, and one in-memory dataset
kc$anti_join(sup_carat, "diamonds", right_query 
 = "cut:fair")
# 
# Do not mind this, removing example indices
elastic::index_delete(kc$connection, "*")
kc <- NULL

}
\references{
Kibio.science: \url{http://kibio.science}, \cr
 Elasticsearch documentation: 
 \url{https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html}
}
\seealso{
\code{\link{kibior}}

\url{https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#time-units} 
 for time-units and \url{https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html#query-string-syntax}
 for the Elasticsearch query string syntax.

: \url{https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html}
 Elasticsearch reindex feature for more information.

: \url{https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html}
 Elasticsearch reindex feature for more information.

\url{https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#time-units} 
 for time-units and \url{https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html#query-string-syntax}
 for the Elasticsearch query string syntax.
}
\author{
RÃ©gis Ongaro-Carcy,
 \email{regis.ongaro-carcy2@crchudequebec.ulaval.ca}
}
\concept{cluster-wealth}
\concept{crud-index}
\concept{crud-metadata}
\concept{data-manipulation}
\concept{joins}
\concept{move-data}
\concept{move-data, search}
\concept{search}
\keyword{data}
\keyword{dataset}
\keyword{integration}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{verbose}}{verbose mode, prints out more informations during execution}

\item{\code{quiet_progress}}{progressbar quiet mode, remove progress bar, useful for cleaner 
tests}

\item{\code{quiet_results}}{results quiet mode, make results of methods invisible}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{host}}{Access and change the Elasticsearch host}

\item{\code{port}}{Access and change the Elasticsearch port}

\item{\code{endpoint}}{Access the Elasticsearch main endpoint}

\item{\code{user}}{Access the Elasticsearch user.}

\item{\code{pwd}}{Access the Elasticsearch password.}

\item{\code{connection}}{Access the Elasticsearch connection object.}

\item{\code{head_search_size}}{Access and change the head size default value.}

\item{\code{cluster_name}}{Access the cluster name if and only if already connected.}

\item{\code{cluster_status}}{Access the cluster status if and only if already connected.}

\item{\code{nb_documents}}{Access the current cluster total number of documents if and only if 
already connected.}

\item{\code{version}}{Access the Elasticsearch version if and only if already connected.}

\item{\code{elastic_wait}}{Access and change the Elasticsearch wait time for update commands if 
and only if already connected.}

\item{\code{valid_joins}}{Access the valid joins available in Kibior.}

\item{\code{valid_count_types}}{Access the valid count types available (mainly observations = 
rows, variables = columns)}

\item{\code{valid_elastic_metadata_types}}{Access the valid Elasticsearch metadata types 
available.}

\item{\code{valid_push_modes}}{Access the valid push modes available.}

\item{\code{shard_number}}{Access and modify the number of allocated primary shards when 
creating an Elasticsearch index.}

\item{\code{shard_replicas_number}}{Access and modify the number of allocated replicas in an 
Elasticsearch index.}

\item{\code{default_id_col}}{Access and modify the default ID column/field created when pushing 
data to Elasticsearch.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{Kibior$new()}}
\item \href{#method-print}{\code{Kibior$print()}}
\item \href{#method-eq}{\code{Kibior$eq()}}
\item \href{#method-ne}{\code{Kibior$ne()}}
\item \href{#method-create}{\code{Kibior$create()}}
\item \href{#method-list}{\code{Kibior$list()}}
\item \href{#method-has}{\code{Kibior$has()}}
\item \href{#method-delete}{\code{Kibior$delete()}}
\item \href{#method-stats}{\code{Kibior$stats()}}
\item \href{#method-ping}{\code{Kibior$ping()}}
\item \href{#method-metadata}{\code{Kibior$metadata()}}
\item \href{#method-mappings}{\code{Kibior$mappings()}}
\item \href{#method-settings}{\code{Kibior$settings()}}
\item \href{#method-aliases}{\code{Kibior$aliases()}}
\item \href{#method-count}{\code{Kibior$count()}}
\item \href{#method-dim}{\code{Kibior$dim()}}
\item \href{#method-columns}{\code{Kibior$columns()}}
\item \href{#method-keys}{\code{Kibior$keys()}}
\item \href{#method-bam_to_tibble}{\code{Kibior$bam_to_tibble()}}
\item \href{#method-soft_cast}{\code{Kibior$soft_cast()}}
\item \href{#method-get_resource}{\code{Kibior$get_resource()}}
\item \href{#method-export}{\code{Kibior$export()}}
\item \href{#method-import_tabular}{\code{Kibior$import_tabular()}}
\item \href{#method-import_features}{\code{Kibior$import_features()}}
\item \href{#method-import_alignments}{\code{Kibior$import_alignments()}}
\item \href{#method-import_json}{\code{Kibior$import_json()}}
\item \href{#method-import_sequences}{\code{Kibior$import_sequences()}}
\item \href{#method-guess_import}{\code{Kibior$guess_import()}}
\item \href{#method-import}{\code{Kibior$import()}}
\item \href{#method-push}{\code{Kibior$push()}}
\item \href{#method-pull}{\code{Kibior$pull()}}
\item \href{#method-move}{\code{Kibior$move()}}
\item \href{#method-copy}{\code{Kibior$copy()}}
\item \href{#method-match}{\code{Kibior$match()}}
\item \href{#method-search}{\code{Kibior$search()}}
\item \href{#method-inner_join}{\code{Kibior$inner_join()}}
\item \href{#method-full_join}{\code{Kibior$full_join()}}
\item \href{#method-left_join}{\code{Kibior$left_join()}}
\item \href{#method-right_join}{\code{Kibior$right_join()}}
\item \href{#method-semi_join}{\code{Kibior$semi_join()}}
\item \href{#method-anti_join}{\code{Kibior$anti_join()}}
\item \href{#method-clone}{\code{Kibior$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$new(
  host = "localhost",
  port = 9200,
  user = NULL,
  pwd = NULL,
  verbose = getOption("verbose")
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{host}}{The target host to connect to Elasticsearch REST API (default: "localhost").}

\item{\code{port}}{The target port (default: 9200).}

\item{\code{user}}{If the server needs authentication, your username (default: NULL).}

\item{\code{pwd}}{If the server needs authentication, your password (default: NULL).}

\item{\code{verbose}}{The verbose mode (default: FALSE).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Initialize a new object, automatically called when calling `Kibior$new()`
}

\subsection{Returns}{
a new instance/object of Kibior
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
# default initiatlization, connect to "localhost:9200"
kc <- Kibior$new()
# connect to "192.168.2.145:9200"
kc <- Kibior$new("192.168.2.145")
# connect to "es:15005", verbose mode activated
kc <- Kibior$new(host = "elasticsearch", port = 15005, verbose = TRUE)
# connect to "192.168.2.145:9450" with credentials "foo:bar"
kc <- Kibior$new(host = "192.168.2.145", port = 9450, user = "foo", pwd = "bar")
# connect to "elasticsearch:9200"
kc <- Kibior$new("elasticsearch")
}

# get kibior var from ".Renviron" file
dd <- system.file("doc_env", "kibior_build.R", package = "kibior")
source(dd, local = TRUE)
kc <- .kibior_get_instance_from_env()
kc$quiet_progress <- TRUE

# preparing all examples (do not mind this for this method)
to_delete <- c(
    "aaa", 
    "bbb", 
    "ccc", 
    "ddd", 
    "sw", 
    "sw_naboo", 
    "sw_tatooine", 
    "sw_alderaan", 
    "sw_from_file", 
    "storms"
)
to_delete[kc$has(to_delete)] \%>\%
    names() \%>\%
    kc$delete()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$print()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Print simple informations of the current object.
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{print(kc)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-eq"></a>}}
\if{latex}{\out{\hypertarget{method-eq}{}}}
\subsection{Method \code{eq()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$eq(other = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{other}}{Another instance/object of Kibior (default: NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Tells if another instance of Kibior has the same `host:port` couple.
}

\subsection{Returns}{
TRUE if hosts and ports are identical, else FALSE
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$eq(kc)


}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ne"></a>}}
\if{latex}{\out{\hypertarget{method-ne}{}}}
\subsection{Method \code{ne()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$ne(other = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{other}}{Another instance/object of Kibior (default: NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Tells if another instance of Kibior has a different `host:port` couple.
}

\subsection{Returns}{
TRUE if hosts and ports are differents, else FALSE
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$ne(kc)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-create"></a>}}
\if{latex}{\out{\hypertarget{method-create}{}}}
\subsection{Method \code{create()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$create(index_name, force = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to create (default: NULL).}

\item{\code{force}}{Erase already existing identical index names? (default: FALSE).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create one or several indices in Elasticsearch.
}

\subsection{Returns}{
a list containing results of creation per index
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$create("aaa")
kc$create(c("bbb", "ccc"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-list"></a>}}
\if{latex}{\out{\hypertarget{method-list}{}}}
\subsection{Method \code{list()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$list(get_specials = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{get_specials}}{a boolean to get special indices (default: FALSE).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
List indices in Elasticsearch.
}

\subsection{Returns}{
a list of index names, NULL if no index found
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$list()
kc$list(get_specials = TRUE)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-has"></a>}}
\if{latex}{\out{\hypertarget{method-has}{}}}
\subsection{Method \code{has()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$has(index_name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to check.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Does Elasticsearch has one or several indices?
}

\subsection{Returns}{
a list with TRUE for found index, else FALSE
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$has("aaa")
c("bbb", "ccc") \%>\% kc$has()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-delete"></a>}}
\if{latex}{\out{\hypertarget{method-delete}{}}}
\subsection{Method \code{delete()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$delete(index_name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to delete.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Delete one or several indices in Elasticsearch.
}

\subsection{Returns}{
a list containing results of deletion per index, or NULL if no index name match
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$delete("aaa")
kc$delete(c("bbb", "ccc"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-stats"></a>}}
\if{latex}{\out{\hypertarget{method-stats}{}}}
\subsection{Method \code{stats()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$stats()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Get stats about Elasticsearch cluster
}

\subsection{Returns}{
a list of statistics about the cluster
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$stats()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ping"></a>}}
\if{latex}{\out{\hypertarget{method-ping}{}}}
\subsection{Method \code{ping()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$ping()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Ping cluster connection
}

\subsection{Returns}{
the ping result with some basic infos
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$ping()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metadata"></a>}}
\if{latex}{\out{\hypertarget{method-metadata}{}}}
\subsection{Method \code{metadata()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$metadata(index_name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to get metadata (default: NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get metadata of indices
}

\subsection{Returns}{
the list of indices, each containing the 3 features (mappings,settings, aliases)
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# push test data, without magrittr
kc$push(dplyr::starwars, "sw")
kc$push(dplyr::filter(dplyr::starwars, homeworld == "Naboo"), "sw_naboo")
kc$push(dplyr::filter(dplyr::starwars, homeworld == "Tatooine"), "sw_tatooine")
kc$push(dplyr::filter(dplyr::starwars, homeworld == "Alderaan"), "sw_alderaan")
# metadata
kc$metadata()
kc$metadata("sw")
kc$metadata(c("sw", "sw_naboo"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mappings"></a>}}
\if{latex}{\out{\hypertarget{method-mappings}{}}}
\subsection{Method \code{mappings()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$mappings(index_name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to get mappings.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get mappings of indices
}

\subsection{Returns}{
the list of indices, containing their mapping
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$mappings()
kc$mappings("sw")
kc$mappings(c("sw", "sw_naboo"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-settings"></a>}}
\if{latex}{\out{\hypertarget{method-settings}{}}}
\subsection{Method \code{settings()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$settings(index_name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to get settings.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get settings of indices
}

\subsection{Returns}{
the list of indices, containing their settings
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$settings()
kc$settings("sw")
kc$settings(c("sw", "sw_tatooine"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-aliases"></a>}}
\if{latex}{\out{\hypertarget{method-aliases}{}}}
\subsection{Method \code{aliases()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$aliases(index_name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to get aliases.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get aliases of indices
}

\subsection{Returns}{
the list of indices, containing their aliases
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$aliases()
kc$aliases("sw")
kc$aliases(c("sw", "sw_alderaan"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-count"></a>}}
\if{latex}{\out{\hypertarget{method-count}{}}}
\subsection{Method \code{count()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$count(index_name, type = "observations", query = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to get aliases.}

\item{\code{type}}{a string representing the type to count: "observations" (lines) or 
"variables" (columns) (default: "observations").}

\item{\code{query}}{a string as a query string syntax (default: NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Count observations or variables in Elasticsearch data
}

\subsection{Returns}{
the list of indices, containing their number of observations or variables. 
 Use `$dim()` for both
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# Number of observations (nb of records) in "sw"
kc$count("sw")
# Number of observations in indices "sw_naboo" and "sw_tatooine"
kc$count(c("sw_naboo", "sw_tatooine"))
# Number of variables (nb of columns) in index "sw_naboo"
kc$count("sw_naboo", type = "variables")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dim"></a>}}
\if{latex}{\out{\hypertarget{method-dim}{}}}
\subsection{Method \code{dim()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$dim(index_name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to get aliases.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Shortcut to `$count()` to match the classical `dim()` function pattern `[line col]`
}

\subsection{Returns}{
the list of indices, containing their number of observations and variables.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# Couple [<nb obs> <nb var>] in "sw"
kc$dim("sw")
# Couple [<nb obs> <nb var>] in indices "sw_naboo" and "sw_alderaan"
kc$dim(c("sw_naboo", "sw_alderaan"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-columns"></a>}}
\if{latex}{\out{\hypertarget{method-columns}{}}}
\subsection{Method \code{columns()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$columns(index_name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names, can be a pattern.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get fields/columns of indices.
}

\subsection{Returns}{
a list of indices, each containing their fields/columns.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$columns("sw")          # direct search
kc$columns("sw_*")        # pattern search

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-keys"></a>}}
\if{latex}{\out{\hypertarget{method-keys}{}}}
\subsection{Method \code{keys()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$keys(index_name, column, max_size = 1000)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{an index name.}

\item{\code{column}}{a field name of this index (default: NULL).}

\item{\code{max_size}}{the maximum result to return (default: 1000).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get distinct keys elements of a specific column.
}

\subsection{Returns}{
a vector of keys values from this field/column
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$keys("sw", "name")
kc$keys("sw", "eye_color")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-bam_to_tibble"></a>}}
\if{latex}{\out{\hypertarget{method-bam_to_tibble}{}}}
\subsection{Method \code{bam_to_tibble()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$bam_to_tibble(bam_data = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{bam_data}}{data from a BAM file (default: NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Transformation function for collapsing the BAM list of lists format 
 into a single list as per the Rsamtools vignette
}

\subsection{Returns}{
a tibble of BAM data
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{dd_bai <- system.file("extdata", "test.bam.bai", package = "kibior")
bam_param <- Rsamtools::ScanBamParam(what = c("pos", "qwidth"))
bam_data <- Rsamtools::scanBam(dd_bai, param = bam_param)
kc$bam_to_tibble(bam_data)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-soft_cast"></a>}}
\if{latex}{\out{\hypertarget{method-soft_cast}{}}}
\subsection{Method \code{soft_cast()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$soft_cast(
  data,
  caster = getFromNamespace("as_tibble", "tibble"),
  caster_args = list(.name_repair = "unique"),
  warn = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{data to cast.}

\item{\code{caster}}{the caster closure/function (default: tibble::as_tibble)}

\item{\code{caster_args}}{others caster args (default: list(.name_repair = "unique"))}

\item{\code{warn}}{do print warning if error? (default: TRUE)}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Casting function that tries to cast a transformation closure. Uses 
 tibble::as_tibble() by default.
}

\subsection{Returns}{
a cast or the unchanged data.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{datasets::iris \%>\% kc$soft_cast()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_resource"></a>}}
\if{latex}{\out{\hypertarget{method-get_resource}{}}}
\subsection{Method \code{get_resource()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$get_resource(url_or_filepath)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{url_or_filepath}}{a filepath or an URL.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get a local filepath or an URL data through a tempfile. If the file
 exists locally, the filepath will be returned, if not, it will tries
 to download the data and return the temp filepath.
}

\subsection{Returns}{
a filepath.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{system.file("R", "kibior.R", package = "kibior") \%>\% 
 kc$get_resource()
"https://ftp.ncbi.nlm.nih.gov/entrez/README" \%>\% kc$get_resource()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-export"></a>}}
\if{latex}{\out{\hypertarget{method-export}{}}}
\subsection{Method \code{export()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$export(data, filepath, format = "csv", force = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{an index name or in-memory data to be extracted to a file.}

\item{\code{filepath}}{the filepath to use as export, must contain the file extention.}

\item{\code{format}}{the file format to use (default: "csv").}

\item{\code{force}}{overwrite the file? (default: FALSE).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Export data to a file.
Some data formats are not installed by default.
Use `rio::install_formats()` to be able to parse them.
}

\subsection{Returns}{
the filepath if correctly exported, else an error
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{f <- tempfile(fileext=".csv")
# export and overwrite last file with the same data from Elasticsearch
kc$export(data = "sw", filepath = f)
# export from in-memory data to a file
kc$export(data = dplyr::starwars, filepath = f, force = TRUE)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-import_tabular"></a>}}
\if{latex}{\out{\hypertarget{method-import_tabular}{}}}
\subsection{Method \code{import_tabular()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$import_tabular(filepath, to_tibble = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{filepath}}{the filepath to use as import, must contain the file extention.}

\item{\code{to_tibble}}{returns the result as tibble? If FALSE, the raw default rio::import() 
format will be used (default: TRUE).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Import method for tabular data.
Works mainly with CSV, TSV, TAB, TXT and ZIPped formats.
}

\subsection{Returns}{
data contained in the file as a tibble, or NULL.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{f <- tempfile(fileext = ".csv")
rio::export(ggplot2::diamonds, f)
# import to in-memory variable
kc$import_tabular(filepath = f)
# import raw data
kc$import_tabular(filepath = f, to_tibble = FALSE)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-import_features"></a>}}
\if{latex}{\out{\hypertarget{method-import_features}{}}}
\subsection{Method \code{import_features()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$import_features(filepath, to_tibble = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{filepath}}{the filepath to use as import, must contain the file extention.}

\item{\code{to_tibble}}{returns the result as tibble? If FALSE, the raw default 
rtracklayer::import() format will be used (default: TRUE).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Import method for features data.
Works with BED, GTF, GFFx, and GZIPped formats.
}

\subsection{Returns}{
data contained in the file as a tibble, or NULL.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# get sample files
f_gff <- system.file("extdata", "chr_y.gff3.gz", package = "kibior")
f_bed <- system.file("extdata", "cpg.bed", package = "kibior")
# import to in-memory variable
kc$import_features(filepath = f_bed)
kc$import_features(filepath = f_gff)
# import raw data
kc$import_features(filepath = f_bed, to_tibble = FALSE)
kc$import_features(filepath = f_gff, to_tibble = FALSE)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-import_alignments"></a>}}
\if{latex}{\out{\hypertarget{method-import_alignments}{}}}
\subsection{Method \code{import_alignments()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$import_alignments(filepath, to_tibble = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{filepath}}{the filepath to use as import, should contain the file extention.}

\item{\code{to_tibble}}{returns the result as tibble? If FALSE, the raw default 
Rsamtools::scanBam() format will be used (default: TRUE).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Import method for alignments data.
Works with BAM format.
}

\subsection{Returns}{
data contained in the file as a tibble, or NULL.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# get sample file
f_bai <- system.file("extdata", "test.bam.bai", package = "kibior")
# import to in-memory variable
kc$import_alignments(filepath = f_bai)
# import raw data
kc$import_alignments(filepath = f_bai, to_tibble = FALSE)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-import_json"></a>}}
\if{latex}{\out{\hypertarget{method-import_json}{}}}
\subsection{Method \code{import_json()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$import_json(filepath, to_tibble = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{filepath}}{the filepath to use as import, should contain the file extention.}

\item{\code{to_tibble}}{returns the result as tibble? If FALSE, the raw dataframe format 
will be used (default: TRUE).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Import method for JSON format.
}

\subsection{Returns}{
data contained in the file as a tibble, dataframe or NULL.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# get sample file
f_json <- system.file("extdata", "storms100.json", package = "kibior")
# import to in-memory variable
kc$import_json(f_json)
# import raw data
kc$import_json(f_json, to_tibble = FALSE)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-import_sequences"></a>}}
\if{latex}{\out{\hypertarget{method-import_sequences}{}}}
\subsection{Method \code{import_sequences()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$import_sequences(filepath, to_tibble = TRUE, fasta_type = "auto")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{filepath}}{the filepath to use as import, should contain the file extention.}

\item{\code{to_tibble}}{returns the result as tibble? If FALSE, the raw default 
Rsamtools::scanBam() format will be used (default: TRUE).}

\item{\code{fasta_type}}{type of parsing. It can be "dna", "rna", "aa" ou "auto" (default: "auto")}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Import method for sequences data.
Works with FASTA formats.
}

\subsection{Returns}{
data contained in the file as a tibble, or NULL.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# get sample file
f_dna <- system.file("extdata", "dna_human_y.fa.gz", package = "kibior")
f_rna <- system.file("extdata", "ncrna_mus_musculus.fa.gz", package = "kibior")
f_aa <- system.file("extdata", "pep_mus_spretus.fa.gz", package = "kibior")
# import to in-memory variable
kc$import_sequences(filepath = f_dna, fasta_type = "dna")
# import raw data
kc$import_sequences(filepath = f_rna, to_tibble = FALSE, fasta_type = "rna")
# import auto
kc$import_sequences(filepath = f_aa)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-guess_import"></a>}}
\if{latex}{\out{\hypertarget{method-guess_import}{}}}
\subsection{Method \code{guess_import()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$guess_import(filepath, to_tibble = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{filepath}}{the filepath to use as import, must contain the file extention.}

\item{\code{to_tibble}}{returns the result as tibble? (default: TRUE).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Import method that will try to guess importation method.
Will also try to read from compressed data if they are.
This method will call other import_* methods when trying.
Some data formats are not installed by default.
Use `rio::install_formats()` to be able to parse them.
}

\subsection{Returns}{
data contained in the file, or NULL.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# get sample file
f_dna <- system.file("extdata", "dna_human_y.fa.gz", package = "kibior")
f_rna <- system.file("extdata", "ncrna_mus_musculus.fa.gz", package = "kibior")
f_aa <- system.file("extdata", "pep_mus_spretus.fa.gz", package = "kibior")
f_bai <- system.file("extdata", "test.bam.bai", package = "kibior")
f_gff <- system.file("extdata", "chr_y.gff3.gz", package = "kibior")
f_bed <- system.file("extdata", "cpg.bed", package = "kibior")
# import 
kc$guess_import(f_dna)
kc$guess_import(f_rna)
kc$guess_import(f_aa)
kc$guess_import(f_bai)
kc$guess_import(f_gff)
kc$guess_import(f_bed)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-import"></a>}}
\if{latex}{\out{\hypertarget{method-import}{}}}
\subsection{Method \code{import()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$import(
  filepath,
  import_type = "auto",
  push_index = NULL,
  push_mode = "check",
  id_col = NULL,
  to_tibble = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{filepath}}{the filepath to use as import, must contain the file extention.}

\item{\code{import_type}}{can be one of "auto", "tabular", "features", "alignments", "sequences" (default: "auto").}

\item{\code{push_index}}{the name of the index where to push data (default: NULL).}

\item{\code{push_mode}}{the push mode (default: "check").}

\item{\code{id_col}}{the column name of unique IDs (default: NULL).}

\item{\code{to_tibble}}{returns the result as tibble? (default: TRUE).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Generic import method.
This method will call other import_* methods when trying.
Some data formats are not installed by default.
}

\subsection{Returns}{
data contained in the file, or NULL.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# get sample file
f_aa <- system.file("extdata", "pep_mus_spretus.fa.gz", package = "kibior")
f_gff <- system.file("extdata", "chr_y.gff3.gz", package = "kibior")
f_bai <- system.file("extdata", "test.bam.bai", package = "kibior")
# import 
kc$import(filepath = f_aa)
# import to Elasticsearch index ("sw_from_file") if not exists
kc$import(filepath = f_bai, push_index = "sw_from_file")
# import to index by recreating it, then pull indexed data
kc$import(filepath = f_gff, push_index = "sw_from_file",
 push_mode = "recreate")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-push"></a>}}
\if{latex}{\out{\hypertarget{method-push}{}}}
\subsection{Method \code{push()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$push(data, index_name, bulk_size = 1000, mode = "check", id_col = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{the data to push.}

\item{\code{index_name}}{the index name to use in Elasticsearch.}

\item{\code{bulk_size}}{the number of record to send to Elasticsearch in a row (default: 1000).}

\item{\code{mode}}{the push mode, could be "check", "recreate" or "update" (default: "check").}

\item{\code{id_col}}{an column anme to use as ID, must be composed of unique elements (default: 
NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Push data from in-memory to Elasticsearch.
Everything is done by bulk.
}

\subsection{Returns}{
the index_name given if the push ended well, else an error.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# erase the last push data by recreating the index and re-pushing data
kc$push(dplyr::starwars, index_name = "sw", mode = "recreate")
# characters names are unique, can be used as ID
kc$push(dplyr::starwars, index_name = "sw", mode = "recreate", id_col = "name")
# a bit more complicated: update some data of the dataset "starwars"
# 38 records on 87 filtered
some_new_data <- dplyr::filter(dplyr::starwars, height > 180)
# make them all "gender <- female"
some_new_data["gender"] <- "female"
# update that apply, based on cahracter names to match the right record
kc$push(some_new_data, "sw", mode = "update", id_col = "name")
# view result by querying
kc$pull("sw", query = "height:>180", columns = c("name", "gender"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pull"></a>}}
\if{latex}{\out{\hypertarget{method-pull}{}}}
\subsection{Method \code{pull()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$pull(
  index_name,
  bulk_size = 500,
  max_size = NULL,
  scroll_timer = "3m",
  keep_metadata = FALSE,
  columns = NULL,
  query = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{the index name to use in Elasticsearch.}

\item{\code{bulk_size}}{the number of record to send to Elasticsearch in a row (default: 500).}

\item{\code{max_size}}{the number of record Elasticsearch will send (default: NULL (all data)).}

\item{\code{scroll_timer}}{the time the scroll API will let the request alive to scroll on the 
result (default: "3m" (3 minute)).}

\item{\code{keep_metadata}}{does Elasticsearch needs to sent metadata? Data columns will be 
prefixed by "_source." (default: FALSE).}

\item{\code{columns}}{a vector of columns to select (default: NULL (all columns)).}

\item{\code{query}}{a string formatted to Elasticsearch query syntax, see links for the syntax 
 details (default: NULL)

# Simple syntax details:}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Pull data from Elasticsearch.
Everything is done by bulk.
This method is essentially a wrapper around `$search()` with parameter `head = FALSE`
}

\subsection{Returns}{
a list of datasets corresponding to the pull request, else an error. Keys of the 
 list are index names matching the request, value are the associated tibbles
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# push some data sample
kc$push(dplyr::storms, "storms")
# get the whole "sw" index
kc$pull("sw")
# get the whole "sw" index with all metadata
kc$pull("sw", keep_metadata = TRUE)
# get only "name" and "status" columns of indices starting with "s"
# columns not found will be ignored
kc$pull("s*", columns = c("name", "status"))
# limit the size of the result to 10
kc$pull("storms", max_size = 10, bulk_size = 10)
# use Elasticsearch query syntax to select and filter on all indices, for all data
# Here, we want to search for all records taht match the conditions:
# field "height" is strictly more than 180 AND field homeworld is "Tatooine" OR "Naboo"
r <- kc$pull("sw", query = "height:>180 && homeworld:(Tatooine || Naboo)")
# it can be used in conjunction with `columns` to select only columns that matter
r <- kc$pull("sw", query = "height:>180 && homeworld:(Tatooine || Naboo)", columns = 
 c("name", "hair_color", "homeworld"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-move"></a>}}
\if{latex}{\out{\hypertarget{method-move}{}}}
\subsection{Method \code{move()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$move(
  from_index,
  to_index,
  from_instance = NULL,
  force = FALSE,
  copy = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{from_index}}{The source index name (default: NULL).}

\item{\code{to_index}}{The destination index name (default: NULL).}

\item{\code{from_instance}}{If not NULL, the Kibior object of another instance. if NULL 
(default), this instance will be used. (default: NULL).}

\item{\code{force}}{Does the destination index need to be erase? (default: FALSE)}

\item{\code{copy}}{Does the destination have to be a copy of the source? FALSE (default) will 
delete source index, TRUE will keep it. (default: FALSE).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Move data from one index to another.
It needs to be configured in the `config/elasticsearch.yml` file to actually work.
}

\subsection{Returns}{
the reindex result
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$push(dplyr::starwars, "sw", mode = "recreate")
# move data from an index to another (change name, same instance)
r <- kc$move(from_index = "sw", to_index = "sw_new")
kc$pull("sw_new")
kc$list() 

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-copy"></a>}}
\if{latex}{\out{\hypertarget{method-copy}{}}}
\subsection{Method \code{copy()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$copy(from_index, to_index, from_instance = NULL, force = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{from_index}}{The source index name (default: NULL).}

\item{\code{to_index}}{The destination index name (default: NULL).}

\item{\code{from_instance}}{If not NULL, the Kibior object of another instance. if NULL 
(default), this instance will be used. (default: NULL).}

\item{\code{force}}{Does the destination index need to be erase? (default: FALSE)}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Copy data from one index to another.
It needs to be configured in the `config/elasticsearch.yml` file to actually work.
This method is a wrapper around `$move(copy = TRUE)`.
}

\subsection{Returns}{
the reindex result
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# copy data from one index to another (same instance)
r <- kc$copy(from_index = "sw_new", to_index = "sw")
kc$pull(c("sw", "sw_new"))
kc$list() 

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-match"></a>}}
\if{latex}{\out{\hypertarget{method-match}{}}}
\subsection{Method \code{match()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$match(index_name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{the index name to use in Elasticsearch, can be a pattern with '*'.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Match requested index names against Elasticsearch indices list.
}

\subsection{Returns}{
a vector of matching index names, NULL if nothing matches.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# search "sw" index name
kc$match("sw")
# search all starting with an "s"
kc$match("s*")
# get all index name, identical to `$list()`
kc$match("*")
# search multiple names 
kc$match(c("sw", "sw_new", "nope"))
# search multiple names with pattern
kc$match(c("s*", "nope"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-search"></a>}}
\if{latex}{\out{\hypertarget{method-search}{}}}
\subsection{Method \code{search()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$search(
  index_name = "_all",
  keep_metadata = FALSE,
  columns = NULL,
  bulk_size = 500,
  max_size = NULL,
  scroll_timer = "3m",
  head = TRUE,
  query = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{the index name to use in Elasticsearch (default: NULL).}

\item{\code{keep_metadata}}{does Elasticsearch needs to sent metadata? Data columns will be 
prefixed by "_source." (default: FALSE).}

\item{\code{columns}}{a vector of columns to select (default: NULL (all columns)).}

\item{\code{bulk_size}}{the number of record to send to Elasticsearch in a row (default: 500).}

\item{\code{max_size}}{the number of record Elasticsearch will send (default: NULL (all data)).}

\item{\code{scroll_timer}}{the time the scroll API will let the request alive to scroll on the 
result (default: "3m" (3 minutes)).}

\item{\code{head}}{a boolean limiting the search result and time (default: TRUE)}

\item{\code{query}}{a string formatted to Elasticsearch query syntax, see links for the syntax 
details (default: NULL)}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Search data from Elasticsearch.
The goal of this method is to discover quickly what data are interesting, thus 
 `head = TRUE` by default.
If you want to get all data, use `head = FALSE` or `$pull()`.
Everything is done by bulk.
}

\subsection{Returns}{
a list of datasets corresponding to the pull request, else an error. Keys of the 
 list are index names matching the request, value are the associated tibbles
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# search "sw" index, head mode on
kc$search("sw")
# search "sw" index with all metadata, head mode on
kc$search("sw", keep_metadata = TRUE)
# get only "name" field of the head of indices starting with "s"
# if an index does not have the "name" field, it will be empty
kc$search("s*", columns = "name")
# limit the size of the result to 50 to the whole index
kc$search("storms", max_size = 50, bulk_size = 50, head = FALSE)
# use Elasticsearch query syntax to select and filter on all indices, for all data
# Here, we want to search for all records taht match the conditions:
# field "height" is strictly more than 180 AND field homeworld is "Tatooine" OR "Naboo"
kc$search("*", query = "height:>180 && homeworld:(Tatooine || Naboo)")
# it can be used in conjunction with `columns` to select only columns that matter
kc$search("*", query = "height:>180 && homeworld:(Tatooine || Naboo)", columns = 
 c("name", "hair_color", "homeworld"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-inner_join"></a>}}
\if{latex}{\out{\hypertarget{method-inner_join}{}}}
\subsection{Method \code{inner_join()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$inner_join(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{see `join()` params.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Execute a inner join between two datasets using `dplyr` joins.
The datasets can be in-memory (variable name) or the name of an currently stored 
 Elasticsearch index. Joins cannot be done on column of type "list" ("by" 
 argument).
}

\subsection{Returns}{
a tibble
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# some data for joins examples
kc$push(ggplot2::diamonds, "diamonds")
# prepare join datasets, only big the biggest diamonds are selected (9)
sup_carat <- dplyr::filter(ggplot2::diamonds, carat > 3.5)
r <- kc$push(sup_carat, "diamonds_superior")
# execute a inner_join with one index and one in-memory dataset
kc$inner_join(ggplot2::diamonds, "diamonds_superior")
# execute a inner_join with one index queried, and one in-memory dataset
kc$inner_join(ggplot2::diamonds, "diamonds", right_query 
 = "carat:>3.5")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-full_join"></a>}}
\if{latex}{\out{\hypertarget{method-full_join}{}}}
\subsection{Method \code{full_join()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$full_join(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{see `join()` params.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Execute a full join between two datasets using `dplyr` joins.
The datasets can be in-memory (variable name) or the name of an currently stored 
 Elasticsearch index. Joins cannot be done on column of type "list" ("by" 
 argument).
}

\subsection{Returns}{
a tibble
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a full_join with one index and one in-memory dataset
kc$full_join(fair_cut, "diamonds_superior")
# execute a full_join with one index queried, and one in-memory dataset
kc$full_join(sup_carat, "diamonds", right_query = "cut:fair")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-left_join"></a>}}
\if{latex}{\out{\hypertarget{method-left_join}{}}}
\subsection{Method \code{left_join()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$left_join(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{see `join()` params.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Execute a left join between two datasets using `dplyr` joins.
The datasets can be in-memory (variable name) or the name of an currently stored 
 Elasticsearch index. Joins cannot be done on column of type "list" ("by" 
 argument).
}

\subsection{Returns}{
a tibble
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a left_join with one index and one in-memory dataset
kc$left_join(fair_cut, "diamonds_superior")
# execute a left_join with one index queried, and one in-memory dataset
kc$left_join(sup_carat, "diamonds", right_query 
 = "cut:fair")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-right_join"></a>}}
\if{latex}{\out{\hypertarget{method-right_join}{}}}
\subsection{Method \code{right_join()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$right_join(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{see `join()` params.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Execute a right join between two datasets using `dplyr` joins.
The datasets can be in-memory (variable name) or the name of an currently stored 
 Elasticsearch index. Joins cannot be done on column of type "list" ("by" 
 argument).
}

\subsection{Returns}{
a tibble
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a right_join with one index and one in-memory dataset
kc$right_join(fair_cut, "diamonds_superior")
# execute a right_join with one index queried, and one in-memory dataset
kc$right_join(sup_carat, "diamonds", right_query 
 = "cut:fair")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-semi_join"></a>}}
\if{latex}{\out{\hypertarget{method-semi_join}{}}}
\subsection{Method \code{semi_join()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$semi_join(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{see `join()` params.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Execute a semi join between two datasets using `dplyr` joins.
The datasets can be in-memory (variable name) or the name of an currently stored 
 Elasticsearch index. Joins cannot be done on column of type "list" ("by" 
 argument).
}

\subsection{Returns}{
a tibble
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a semi_join with one index and one in-memory dataset
kc$semi_join(fair_cut, "diamonds_superior")
# execute a semi_join with one index queried, and one in-memory dataset
kc$semi_join(sup_carat, "diamonds", right_query 
 = "cut:fair")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-anti_join"></a>}}
\if{latex}{\out{\hypertarget{method-anti_join}{}}}
\subsection{Method \code{anti_join()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$anti_join(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{see `join()` params.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Execute a anti join between two datasets using `dplyr` joins.
The datasets can be in-memory (variable name) or the name of an currently stored 
 Elasticsearch index. Joins cannot be done on column of type "list" ("by" 
 argument).
}

\subsection{Returns}{
a tibble
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a anti_join with one index and one in-memory dataset
kc$anti_join(fair_cut, "diamonds_superior")
# execute a anti_join with one index queried, and one in-memory dataset
kc$anti_join(sup_carat, "diamonds", right_query 
 = "cut:fair")
# 
# Do not mind this, removing example indices
elastic::index_delete(kc$connection, "*")
kc <- NULL

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
